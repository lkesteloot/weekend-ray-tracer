// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Scene.proto

#ifndef PROTOBUF_Scene_2eproto__INCLUDED
#define PROTOBUF_Scene_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Scene {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Scene_2eproto();
void protobuf_AssignDesc_Scene_2eproto();
void protobuf_ShutdownFile_Scene_2eproto();

class Vec3;
class Quat;
class Camera;
class Thing;
class World;
class Scene;

enum Shape {
  SHAPE_SPHERE = 1,
  SHAPE_BOX = 2,
  SHAPE_XY_RECT = 3,
  SHAPE_XZ_RECT = 4,
  SHAPE_YZ_RECT = 5
};
bool Shape_IsValid(int value);
const Shape Shape_MIN = SHAPE_SPHERE;
const Shape Shape_MAX = SHAPE_YZ_RECT;
const int Shape_ARRAYSIZE = Shape_MAX + 1;

const ::google::protobuf::EnumDescriptor* Shape_descriptor();
inline const ::std::string& Shape_Name(Shape value) {
  return ::google::protobuf::internal::NameOfEnum(
    Shape_descriptor(), value);
}
inline bool Shape_Parse(
    const ::std::string& name, Shape* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Shape>(
    Shape_descriptor(), name, value);
}
// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Scene.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Quat : public ::google::protobuf::Message {
 public:
  Quat();
  virtual ~Quat();

  Quat(const Quat& from);

  inline Quat& operator=(const Quat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quat& default_instance();

  void Swap(Quat* other);

  // implements Message ----------------------------------------------

  Quat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quat& from);
  void MergeFrom(const Quat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // required float w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline float w() const;
  inline void set_w(float value);

  // @@protoc_insertion_point(class_scope:Scene.Quat)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static Quat* default_instance_;
};
// -------------------------------------------------------------------

class Camera : public ::google::protobuf::Message {
 public:
  Camera();
  virtual ~Camera();

  Camera(const Camera& from);

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera& default_instance();

  void Swap(Camera* other);

  // implements Message ----------------------------------------------

  Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Scene.Vec3 look_from = 1;
  inline bool has_look_from() const;
  inline void clear_look_from();
  static const int kLookFromFieldNumber = 1;
  inline const ::Scene::Vec3& look_from() const;
  inline ::Scene::Vec3* mutable_look_from();
  inline ::Scene::Vec3* release_look_from();
  inline void set_allocated_look_from(::Scene::Vec3* look_from);

  // optional .Scene.Vec3 look_at = 2;
  inline bool has_look_at() const;
  inline void clear_look_at();
  static const int kLookAtFieldNumber = 2;
  inline const ::Scene::Vec3& look_at() const;
  inline ::Scene::Vec3* mutable_look_at();
  inline ::Scene::Vec3* release_look_at();
  inline void set_allocated_look_at(::Scene::Vec3* look_at);

  // optional float aperature = 3;
  inline bool has_aperature() const;
  inline void clear_aperature();
  static const int kAperatureFieldNumber = 3;
  inline float aperature() const;
  inline void set_aperature(float value);

  // optional float vertical_fov = 4;
  inline bool has_vertical_fov() const;
  inline void clear_vertical_fov();
  static const int kVerticalFovFieldNumber = 4;
  inline float vertical_fov() const;
  inline void set_vertical_fov(float value);

  // @@protoc_insertion_point(class_scope:Scene.Camera)
 private:
  inline void set_has_look_from();
  inline void clear_has_look_from();
  inline void set_has_look_at();
  inline void clear_has_look_at();
  inline void set_has_aperature();
  inline void clear_has_aperature();
  inline void set_has_vertical_fov();
  inline void clear_has_vertical_fov();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Scene::Vec3* look_from_;
  ::Scene::Vec3* look_at_;
  float aperature_;
  float vertical_fov_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static Camera* default_instance_;
};
// -------------------------------------------------------------------

class Thing : public ::google::protobuf::Message {
 public:
  Thing();
  virtual ~Thing();

  Thing(const Thing& from);

  inline Thing& operator=(const Thing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thing& default_instance();

  void Swap(Thing* other);

  // implements Message ----------------------------------------------

  Thing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Thing& from);
  void MergeFrom(const Thing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Scene.Shape shape = 1;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 1;
  inline ::Scene::Shape shape() const;
  inline void set_shape(::Scene::Shape value);

  // optional .Scene.Vec3 center = 2;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 2;
  inline const ::Scene::Vec3& center() const;
  inline ::Scene::Vec3* mutable_center();
  inline ::Scene::Vec3* release_center();
  inline void set_allocated_center(::Scene::Vec3* center);

  // optional .Scene.Vec3 half_size = 3;
  inline bool has_half_size() const;
  inline void clear_half_size();
  static const int kHalfSizeFieldNumber = 3;
  inline const ::Scene::Vec3& half_size() const;
  inline ::Scene::Vec3* mutable_half_size();
  inline ::Scene::Vec3* release_half_size();
  inline void set_allocated_half_size(::Scene::Vec3* half_size);

  // optional .Scene.Quat orientation = 4;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  inline const ::Scene::Quat& orientation() const;
  inline ::Scene::Quat* mutable_orientation();
  inline ::Scene::Quat* release_orientation();
  inline void set_allocated_orientation(::Scene::Quat* orientation);

  // optional .Scene.Vec3 color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline const ::Scene::Vec3& color() const;
  inline ::Scene::Vec3* mutable_color();
  inline ::Scene::Vec3* release_color();
  inline void set_allocated_color(::Scene::Vec3* color);

  // optional bool is_light = 6;
  inline bool has_is_light() const;
  inline void clear_is_light();
  static const int kIsLightFieldNumber = 6;
  inline bool is_light() const;
  inline void set_is_light(bool value);

  // @@protoc_insertion_point(class_scope:Scene.Thing)
 private:
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_half_size();
  inline void clear_has_half_size();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_is_light();
  inline void clear_has_is_light();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Scene::Vec3* center_;
  ::Scene::Vec3* half_size_;
  int shape_;
  bool is_light_;
  ::Scene::Quat* orientation_;
  ::Scene::Vec3* color_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static Thing* default_instance_;
};
// -------------------------------------------------------------------

class World : public ::google::protobuf::Message {
 public:
  World();
  virtual ~World();

  World(const World& from);

  inline World& operator=(const World& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const World& default_instance();

  void Swap(World* other);

  // implements Message ----------------------------------------------

  World* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const World& from);
  void MergeFrom(const World& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Scene.Vec3 background_color = 1;
  inline bool has_background_color() const;
  inline void clear_background_color();
  static const int kBackgroundColorFieldNumber = 1;
  inline const ::Scene::Vec3& background_color() const;
  inline ::Scene::Vec3* mutable_background_color();
  inline ::Scene::Vec3* release_background_color();
  inline void set_allocated_background_color(::Scene::Vec3* background_color);

  // optional .Scene.Camera camera = 2;
  inline bool has_camera() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 2;
  inline const ::Scene::Camera& camera() const;
  inline ::Scene::Camera* mutable_camera();
  inline ::Scene::Camera* release_camera();
  inline void set_allocated_camera(::Scene::Camera* camera);

  // repeated .Scene.Thing thing = 3;
  inline int thing_size() const;
  inline void clear_thing();
  static const int kThingFieldNumber = 3;
  inline const ::Scene::Thing& thing(int index) const;
  inline ::Scene::Thing* mutable_thing(int index);
  inline ::Scene::Thing* add_thing();
  inline const ::google::protobuf::RepeatedPtrField< ::Scene::Thing >&
      thing() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scene::Thing >*
      mutable_thing();

  // @@protoc_insertion_point(class_scope:Scene.World)
 private:
  inline void set_has_background_color();
  inline void clear_has_background_color();
  inline void set_has_camera();
  inline void clear_has_camera();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Scene::Vec3* background_color_;
  ::Scene::Camera* camera_;
  ::google::protobuf::RepeatedPtrField< ::Scene::Thing > thing_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static World* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Scene.World world = 1;
  inline int world_size() const;
  inline void clear_world();
  static const int kWorldFieldNumber = 1;
  inline const ::Scene::World& world(int index) const;
  inline ::Scene::World* mutable_world(int index);
  inline ::Scene::World* add_world();
  inline const ::google::protobuf::RepeatedPtrField< ::Scene::World >&
      world() const;
  inline ::google::protobuf::RepeatedPtrField< ::Scene::World >*
      mutable_world();

  // @@protoc_insertion_point(class_scope:Scene.Scene)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Scene::World > world_;
  friend void  protobuf_AddDesc_Scene_2eproto();
  friend void protobuf_AssignDesc_Scene_2eproto();
  friend void protobuf_ShutdownFile_Scene_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// required float x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:Scene.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Scene.Vec3.x)
}

// required float y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:Scene.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Scene.Vec3.y)
}

// required float z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:Scene.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Scene.Vec3.z)
}

// -------------------------------------------------------------------

// Quat

// required float x = 1;
inline bool Quat::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quat::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quat::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quat::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Quat::x() const {
  // @@protoc_insertion_point(field_get:Scene.Quat.x)
  return x_;
}
inline void Quat::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Scene.Quat.x)
}

// required float y = 2;
inline bool Quat::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quat::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quat::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quat::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Quat::y() const {
  // @@protoc_insertion_point(field_get:Scene.Quat.y)
  return y_;
}
inline void Quat::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Scene.Quat.y)
}

// required float z = 3;
inline bool Quat::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quat::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quat::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quat::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Quat::z() const {
  // @@protoc_insertion_point(field_get:Scene.Quat.z)
  return z_;
}
inline void Quat::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Scene.Quat.z)
}

// required float w = 4;
inline bool Quat::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quat::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quat::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quat::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Quat::w() const {
  // @@protoc_insertion_point(field_get:Scene.Quat.w)
  return w_;
}
inline void Quat::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Scene.Quat.w)
}

// -------------------------------------------------------------------

// Camera

// optional .Scene.Vec3 look_from = 1;
inline bool Camera::has_look_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Camera::set_has_look_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Camera::clear_has_look_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Camera::clear_look_from() {
  if (look_from_ != NULL) look_from_->::Scene::Vec3::Clear();
  clear_has_look_from();
}
inline const ::Scene::Vec3& Camera::look_from() const {
  // @@protoc_insertion_point(field_get:Scene.Camera.look_from)
  return look_from_ != NULL ? *look_from_ : *default_instance_->look_from_;
}
inline ::Scene::Vec3* Camera::mutable_look_from() {
  set_has_look_from();
  if (look_from_ == NULL) look_from_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.Camera.look_from)
  return look_from_;
}
inline ::Scene::Vec3* Camera::release_look_from() {
  clear_has_look_from();
  ::Scene::Vec3* temp = look_from_;
  look_from_ = NULL;
  return temp;
}
inline void Camera::set_allocated_look_from(::Scene::Vec3* look_from) {
  delete look_from_;
  look_from_ = look_from;
  if (look_from) {
    set_has_look_from();
  } else {
    clear_has_look_from();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Camera.look_from)
}

// optional .Scene.Vec3 look_at = 2;
inline bool Camera::has_look_at() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Camera::set_has_look_at() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Camera::clear_has_look_at() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Camera::clear_look_at() {
  if (look_at_ != NULL) look_at_->::Scene::Vec3::Clear();
  clear_has_look_at();
}
inline const ::Scene::Vec3& Camera::look_at() const {
  // @@protoc_insertion_point(field_get:Scene.Camera.look_at)
  return look_at_ != NULL ? *look_at_ : *default_instance_->look_at_;
}
inline ::Scene::Vec3* Camera::mutable_look_at() {
  set_has_look_at();
  if (look_at_ == NULL) look_at_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.Camera.look_at)
  return look_at_;
}
inline ::Scene::Vec3* Camera::release_look_at() {
  clear_has_look_at();
  ::Scene::Vec3* temp = look_at_;
  look_at_ = NULL;
  return temp;
}
inline void Camera::set_allocated_look_at(::Scene::Vec3* look_at) {
  delete look_at_;
  look_at_ = look_at;
  if (look_at) {
    set_has_look_at();
  } else {
    clear_has_look_at();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Camera.look_at)
}

// optional float aperature = 3;
inline bool Camera::has_aperature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Camera::set_has_aperature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Camera::clear_has_aperature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Camera::clear_aperature() {
  aperature_ = 0;
  clear_has_aperature();
}
inline float Camera::aperature() const {
  // @@protoc_insertion_point(field_get:Scene.Camera.aperature)
  return aperature_;
}
inline void Camera::set_aperature(float value) {
  set_has_aperature();
  aperature_ = value;
  // @@protoc_insertion_point(field_set:Scene.Camera.aperature)
}

// optional float vertical_fov = 4;
inline bool Camera::has_vertical_fov() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Camera::set_has_vertical_fov() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Camera::clear_has_vertical_fov() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Camera::clear_vertical_fov() {
  vertical_fov_ = 0;
  clear_has_vertical_fov();
}
inline float Camera::vertical_fov() const {
  // @@protoc_insertion_point(field_get:Scene.Camera.vertical_fov)
  return vertical_fov_;
}
inline void Camera::set_vertical_fov(float value) {
  set_has_vertical_fov();
  vertical_fov_ = value;
  // @@protoc_insertion_point(field_set:Scene.Camera.vertical_fov)
}

// -------------------------------------------------------------------

// Thing

// optional .Scene.Shape shape = 1;
inline bool Thing::has_shape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thing::set_has_shape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thing::clear_has_shape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thing::clear_shape() {
  shape_ = 1;
  clear_has_shape();
}
inline ::Scene::Shape Thing::shape() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.shape)
  return static_cast< ::Scene::Shape >(shape_);
}
inline void Thing::set_shape(::Scene::Shape value) {
  assert(::Scene::Shape_IsValid(value));
  set_has_shape();
  shape_ = value;
  // @@protoc_insertion_point(field_set:Scene.Thing.shape)
}

// optional .Scene.Vec3 center = 2;
inline bool Thing::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thing::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thing::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thing::clear_center() {
  if (center_ != NULL) center_->::Scene::Vec3::Clear();
  clear_has_center();
}
inline const ::Scene::Vec3& Thing::center() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.center)
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::Scene::Vec3* Thing::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.Thing.center)
  return center_;
}
inline ::Scene::Vec3* Thing::release_center() {
  clear_has_center();
  ::Scene::Vec3* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Thing::set_allocated_center(::Scene::Vec3* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Thing.center)
}

// optional .Scene.Vec3 half_size = 3;
inline bool Thing::has_half_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thing::set_has_half_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thing::clear_has_half_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thing::clear_half_size() {
  if (half_size_ != NULL) half_size_->::Scene::Vec3::Clear();
  clear_has_half_size();
}
inline const ::Scene::Vec3& Thing::half_size() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.half_size)
  return half_size_ != NULL ? *half_size_ : *default_instance_->half_size_;
}
inline ::Scene::Vec3* Thing::mutable_half_size() {
  set_has_half_size();
  if (half_size_ == NULL) half_size_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.Thing.half_size)
  return half_size_;
}
inline ::Scene::Vec3* Thing::release_half_size() {
  clear_has_half_size();
  ::Scene::Vec3* temp = half_size_;
  half_size_ = NULL;
  return temp;
}
inline void Thing::set_allocated_half_size(::Scene::Vec3* half_size) {
  delete half_size_;
  half_size_ = half_size;
  if (half_size) {
    set_has_half_size();
  } else {
    clear_has_half_size();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Thing.half_size)
}

// optional .Scene.Quat orientation = 4;
inline bool Thing::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Thing::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Thing::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Thing::clear_orientation() {
  if (orientation_ != NULL) orientation_->::Scene::Quat::Clear();
  clear_has_orientation();
}
inline const ::Scene::Quat& Thing::orientation() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::Scene::Quat* Thing::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::Scene::Quat;
  // @@protoc_insertion_point(field_mutable:Scene.Thing.orientation)
  return orientation_;
}
inline ::Scene::Quat* Thing::release_orientation() {
  clear_has_orientation();
  ::Scene::Quat* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Thing::set_allocated_orientation(::Scene::Quat* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Thing.orientation)
}

// optional .Scene.Vec3 color = 5;
inline bool Thing::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Thing::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Thing::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Thing::clear_color() {
  if (color_ != NULL) color_->::Scene::Vec3::Clear();
  clear_has_color();
}
inline const ::Scene::Vec3& Thing::color() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Scene::Vec3* Thing::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.Thing.color)
  return color_;
}
inline ::Scene::Vec3* Thing::release_color() {
  clear_has_color();
  ::Scene::Vec3* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Thing::set_allocated_color(::Scene::Vec3* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.Thing.color)
}

// optional bool is_light = 6;
inline bool Thing::has_is_light() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Thing::set_has_is_light() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Thing::clear_has_is_light() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Thing::clear_is_light() {
  is_light_ = false;
  clear_has_is_light();
}
inline bool Thing::is_light() const {
  // @@protoc_insertion_point(field_get:Scene.Thing.is_light)
  return is_light_;
}
inline void Thing::set_is_light(bool value) {
  set_has_is_light();
  is_light_ = value;
  // @@protoc_insertion_point(field_set:Scene.Thing.is_light)
}

// -------------------------------------------------------------------

// World

// optional .Scene.Vec3 background_color = 1;
inline bool World::has_background_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void World::set_has_background_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void World::clear_has_background_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void World::clear_background_color() {
  if (background_color_ != NULL) background_color_->::Scene::Vec3::Clear();
  clear_has_background_color();
}
inline const ::Scene::Vec3& World::background_color() const {
  // @@protoc_insertion_point(field_get:Scene.World.background_color)
  return background_color_ != NULL ? *background_color_ : *default_instance_->background_color_;
}
inline ::Scene::Vec3* World::mutable_background_color() {
  set_has_background_color();
  if (background_color_ == NULL) background_color_ = new ::Scene::Vec3;
  // @@protoc_insertion_point(field_mutable:Scene.World.background_color)
  return background_color_;
}
inline ::Scene::Vec3* World::release_background_color() {
  clear_has_background_color();
  ::Scene::Vec3* temp = background_color_;
  background_color_ = NULL;
  return temp;
}
inline void World::set_allocated_background_color(::Scene::Vec3* background_color) {
  delete background_color_;
  background_color_ = background_color;
  if (background_color) {
    set_has_background_color();
  } else {
    clear_has_background_color();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.World.background_color)
}

// optional .Scene.Camera camera = 2;
inline bool World::has_camera() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void World::set_has_camera() {
  _has_bits_[0] |= 0x00000002u;
}
inline void World::clear_has_camera() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void World::clear_camera() {
  if (camera_ != NULL) camera_->::Scene::Camera::Clear();
  clear_has_camera();
}
inline const ::Scene::Camera& World::camera() const {
  // @@protoc_insertion_point(field_get:Scene.World.camera)
  return camera_ != NULL ? *camera_ : *default_instance_->camera_;
}
inline ::Scene::Camera* World::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) camera_ = new ::Scene::Camera;
  // @@protoc_insertion_point(field_mutable:Scene.World.camera)
  return camera_;
}
inline ::Scene::Camera* World::release_camera() {
  clear_has_camera();
  ::Scene::Camera* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void World::set_allocated_camera(::Scene::Camera* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:Scene.World.camera)
}

// repeated .Scene.Thing thing = 3;
inline int World::thing_size() const {
  return thing_.size();
}
inline void World::clear_thing() {
  thing_.Clear();
}
inline const ::Scene::Thing& World::thing(int index) const {
  // @@protoc_insertion_point(field_get:Scene.World.thing)
  return thing_.Get(index);
}
inline ::Scene::Thing* World::mutable_thing(int index) {
  // @@protoc_insertion_point(field_mutable:Scene.World.thing)
  return thing_.Mutable(index);
}
inline ::Scene::Thing* World::add_thing() {
  // @@protoc_insertion_point(field_add:Scene.World.thing)
  return thing_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scene::Thing >&
World::thing() const {
  // @@protoc_insertion_point(field_list:Scene.World.thing)
  return thing_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scene::Thing >*
World::mutable_thing() {
  // @@protoc_insertion_point(field_mutable_list:Scene.World.thing)
  return &thing_;
}

// -------------------------------------------------------------------

// Scene

// repeated .Scene.World world = 1;
inline int Scene::world_size() const {
  return world_.size();
}
inline void Scene::clear_world() {
  world_.Clear();
}
inline const ::Scene::World& Scene::world(int index) const {
  // @@protoc_insertion_point(field_get:Scene.Scene.world)
  return world_.Get(index);
}
inline ::Scene::World* Scene::mutable_world(int index) {
  // @@protoc_insertion_point(field_mutable:Scene.Scene.world)
  return world_.Mutable(index);
}
inline ::Scene::World* Scene::add_world() {
  // @@protoc_insertion_point(field_add:Scene.Scene.world)
  return world_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Scene::World >&
Scene::world() const {
  // @@protoc_insertion_point(field_list:Scene.Scene.world)
  return world_;
}
inline ::google::protobuf::RepeatedPtrField< ::Scene::World >*
Scene::mutable_world() {
  // @@protoc_insertion_point(field_mutable_list:Scene.Scene.world)
  return &world_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Scene

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Scene::Shape> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Scene::Shape>() {
  return ::Scene::Shape_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Scene_2eproto__INCLUDED
